### Step 12: Analyze Flow - API Service + In-Memory Store
### Testing the frontend's API service integration and centralized state management

### WHAT'S NEW IN STEP 12:
# - Created dedicated ApiService for backend communication with proper error handling
# - Implemented centralized StateService for analysis payload and UI state management
# - Enhanced Explorer component to use reactive state management with RxJS observables
# - Added comprehensive error handling for all six standard error codes with exact message format
# - Implemented visible "Analyzing..." loading state during requests
# - Added proper error display with dismissible alerts and user-friendly messages
# - Refactored component to use dependency injection and reactive programming patterns

### Key Differences to Look For:
# 1. **Centralized State Management**: All analysis data and UI state now managed in StateService
# 2. **Reactive Updates**: Component subscribes to state changes using RxJS observables
# 3. **Enhanced Error Handling**: Standardized error processing with user-friendly display messages
# 4. **Loading States**: Proper "Analyzing..." feedback with spinner during API calls
# 5. **Service Architecture**: Clean separation between API communication and state management
# 6. **Error Display**: Dismissible error alerts with Material Icons and proper styling

### Backend Tests (Verify API functionality)

### Test 1: Valid Repository Analysis
POST http://localhost:5000/analyze
Content-Type: application/json

{
  "repoUrl": "https://github.com/nunit/nunit.git"
}

### Expected Result:
# - HTTP 200 OK
# - Complete analysis payload with meta, graphs, metrics, cycles
# - Frontend should show "Analyzing..." then success with node/edge counts
# - State should be properly updated in StateService

### Test 2: Invalid Repository (CloneFailed)
POST http://localhost:5000/analyze
Content-Type: application/json

{
  "repoUrl": "https://github.com/nonexistent/invalid-repo.git"
}

### Expected Result:
# - HTTP 502 Bad Gateway
# - Error response: {"error": "CloneFailed", "message": "..."}
# - Frontend should display: "Clone Failed: [exact message from backend]"
# - Error should be dismissible with close button

### Test 3: Non-C# Repository (NoSolutionOrProject)
POST http://localhost:5000/analyze
Content-Type: application/json

{
  "repoUrl": "https://github.com/microsoft/TypeScript.git"
}

### Expected Result:
# - HTTP 400 Bad Request
# - Error response: {"error": "NoSolutionOrProject", "message": "..."}
# - Frontend should display: "Repository Error: [exact message from backend]"

### Test 4: Large Repository (LimitsExceeded)
POST http://localhost:5000/analyze
Content-Type: application/json

{
  "repoUrl": "https://github.com/dotnet/runtime.git"
}

### Expected Result (if over limits):
# - HTTP 413 Payload Too Large
# - Error response: {"error": "LimitsExceeded", "message": "..."}
# - Frontend should display: "Size Limit Exceeded: [exact message from backend]"

### Frontend UI Tests (Manual Testing Required)

### Test 5: Frontend Loading States
# Steps:
# 1. Open http://localhost:4200
# 2. Enter valid repo URL: https://github.com/nunit/nunit.git
# 3. Click "Analyze" button
# 
# Expected Behavior:
# - Button text changes to "Analyzing..." immediately
# - Button becomes disabled during request
# - Loading spinner appears in main area with "Analyzing repository..." message
# - "This may take a few minutes for large repositories" helper text visible
# - After completion: Success message with node/edge counts
# - Button returns to "Analyze" and becomes enabled

### Test 6: Error Display and Dismissal
# Steps:
# 1. Enter invalid URL: https://github.com/invalid/repo.git
# 2. Click "Analyze"
# 
# Expected Behavior:
# - Shows loading state initially
# - After failure: Red error alert appears with:
#   - Error icon (Material Icons error symbol)
#   - Error message: "Clone Failed: [backend message]"
#   - Dismissible close button (X)
# - Clicking X should clear the error
# - Error should not reappear until next failure

### Test 7: Scope Toggle and State Management
# Steps:
# 1. Complete successful analysis
# 2. Toggle between "Namespace" and "File" scope buttons
# 
# Expected Behavior:
# - Radio buttons should update properly
# - Node/edge counts should change based on scope
# - State should persist across scope changes
# - No re-analysis required for scope switching

### Test 8: Search State Management
# Steps:
# 1. Complete successful analysis  
# 2. Type in search box: "nunit"
# 
# Expected Behavior:
# - Search term should be stored in StateService
# - Input should reflect current search state
# - Search state should persist across component interactions
# - (Search filtering will be implemented in Step 13)

### Test 9: Save/Load with State Management
# Steps:
# 1. Complete successful analysis
# 2. Click "Save" button
# 3. Refresh page (or reload app)
# 4. Click "Load" and select saved file
# 
# Expected Behavior:
# - Save: Downloads .codeatlas.json file with analysis data
# - After reload: App returns to initial state
# - Load: File picker opens, after selection analysis data restored
# - State should be fully restored including scope, node counts

### Test 10: Network Error Handling
# Steps:
# 1. Stop the backend API server (Ctrl+C in API terminal)
# 2. Try to analyze any repository
# 
# Expected Behavior:
# - Shows loading state initially
# - After timeout: Error alert appears with:
#   - "Connection Error: Unable to connect to the analysis server..."
#   - Proper error styling and dismissible alert
# - Restart API server and retry should work normally

### Test 11: Multiple Error Scenarios
# Test all six error codes by triggering different backend conditions:
# 
# Error Code Mapping (verify exact display titles):
# - NoSolutionOrProject → "Repository Error"
# - MissingSdk → "SDK Missing"  
# - BuildFailed → "Build Failed"
# - CloneFailed → "Clone Failed"
# - Timeout → "Request Timeout"
# - LimitsExceeded → "Size Limit Exceeded"
# - NetworkError → "Connection Error" (frontend-generated)
# - UnknownError → "Analysis Error" (fallback)

### Test 12: State Service Integration
# Verify StateService functionality through browser dev tools:
# 
# Steps:
# 1. Open browser dev tools → Console
# 2. Complete analysis
# 3. Run: `ng.getComponent($0).stateService.currentState`
# 
# Expected State Structure:
# {
#   analysisResult: { meta: {...}, graphs: {...}, metrics: {...}, cycles: [...] },
#   isAnalyzing: false,
#   error: null,
#   ui: {
#     currentScope: 'namespace',
#     selectedNodeId: null,
#     searchTerm: '',
#     activeFilters: [],
#     isNeighborsOnly: false,
#     isImpactMode: false,
#     pathModeSource: null,
#     pathModeTarget: null
#   }
# }

### Development Notes for Step 12:
# - API service uses RxJS observables for reactive programming
# - State service implements BehaviorSubject for state broadcasting
# - Component properly subscribes/unsubscribes to prevent memory leaks
# - Error handling provides both technical and user-friendly messages
# - All UI state is centralized and ready for graph visualization in Step 13
# - Loading states provide clear feedback during potentially long-running operations

### Next Step Preparation:
# Step 13 will add:
# - Cytoscape.js graph canvas integration
# - Node selection with right drawer details
# - Filter tree (namespace/folder hierarchy)
# - Search functionality with node highlighting
# - Neighbors-only mode for focused exploration
# 
# The state management architecture implemented in Step 12 provides the foundation
# for all these interactive features.
